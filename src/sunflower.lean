import algebra.big_operators.ring
import data.finset.finsupp
import probability.density
import probability.independence
import probability.conditional_expectation
import probability.notation
import probability.cond_count
import analysis.special_functions.log.base
import data.nat.basic
import data.finset.basic

open finset measure_theory probability_theory
open_locale big_operators measure_theory ennreal

variables {Œ± : Type*} [decidable_eq Œ±]
variables {ùíÆ : finset (finset Œ±)} {G : finset (finset Œ±)} {U : finset Œ±} {t : ‚Ñï}

section partition

  def tuples_on (s : finset Œ±) (m t : ‚Ñï) : finset (‚Ñï ‚Üí finset Œ±) :=
  (finset.pi (range t) (Œª _, s.powerset_len m)).map $
    { to_fun := Œª f i, if h : i < t then f i (by simpa using h) else ‚àÖ,
      inj' :=
      begin
        rintro f g h,
        ext x hx : 2,
        simpa [dif_pos (finset.mem_range.1 hx)] using function.funext_iff.1 h x,
      end }

  lemma mem_tuples_on {m t : ‚Ñï} {s : finset Œ±} (f : ‚Ñï ‚Üí finset Œ±) :
    f ‚àà tuples_on s m t ‚Üî (‚àÄ i < t, f i ‚äÜ s ‚àß (f i).card = m) ‚àß ‚àÄ i ‚â• t, f i = ‚àÖ :=
  begin
    simp only [tuples_on, finset.mem_map, finset.mem_range, finset.mem_pi,
      function.embedding.coe_fn_mk, exists_prop, ge_iff_le, mem_powerset_len],
    split,
    { rintro ‚ü®f, hf‚ÇÅ, rfl‚ü©,
      refine ‚ü®Œª i hi, _, Œª i hi, _‚ü©,
      { simpa [dif_pos hi] using hf‚ÇÅ _ hi },
      simp only [dif_neg hi.not_lt] },
    rintro ‚ü®hf‚ÇÅ, hf‚ÇÇ‚ü©,
    refine ‚ü®Œª i _, f i, hf‚ÇÅ, _‚ü©,
    ext i : 1,
    split_ifs,
    { refl },
    rw hf‚ÇÇ _ (le_of_not_lt h),
  end

  -- We view s,m,t- partitions as ordered sequences W0, W1, W2, ... with the conditions:
  --   Wj for j ‚â• t is empty
  --      (essentially this says W is defined up to but not including t)
  --   Wj for j < t is a subset of s
  --   Wj for j < t has cardinality m
  --   the collection {Wj for j < t} is pairwise disjoint
  -- In most cases we will have `s` as our entire finite universe
  -- NOTE the union of the Wj might not be s

  -- This is not a standard way of defining partitions, but it is *vital* for ours to be ordered
  -- so I use this version
  -- `partitions_on s m t` is the finite set of these partitions
  -- its Lean definition isn't very helpful, but `mem_partitions_on` says it does what it's meant to.
  -- So when proving things about `partitions_on`, you almost always want to be using this lemma
  -- rather than the definition (or `mem_partitions_on'` which is logically equivalent but sometimes
  -- may be more useful)

  def partitions_on (s : finset Œ±) (m t : ‚Ñï) : finset (‚Ñï ‚Üí finset Œ±) :=
  (tuples_on s m t).filter (Œª f, ‚àÄ i j < t, i ‚â† j ‚Üí disjoint (f i) (f j))

  lemma mem_partitions_on {m t : ‚Ñï} {s : finset Œ±} (f : ‚Ñï ‚Üí finset Œ±) :
    f ‚àà partitions_on s m t ‚Üî
      (‚àÄ i < t, f i ‚äÜ s ‚àß (f i).card = m) ‚àß (‚àÄ i ‚â• t, f i = ‚àÖ) ‚àß
      ‚àÄ i j < t, i ‚â† j ‚Üí disjoint (f i) (f j) :=
  by simp only [partitions_on, mem_filter, mem_tuples_on, and_assoc]

  lemma mem_partitions_on' {m t : ‚Ñï} {s : finset Œ±} (f : ‚Ñï ‚Üí finset Œ±) :
    f ‚àà partitions_on s m t ‚Üî
      (‚àÄ i < t, (f i).card = m) ‚àß
      (‚àÄ i ‚â• t, f i = ‚àÖ) ‚àß
      (‚àÄ i, f i ‚äÜ s) ‚àß
      ‚àÄ i j, i ‚â† j ‚Üí disjoint (f i) (f j) :=
  begin
    rw mem_partitions_on,
    split,
    { rintro ‚ü®hf‚ÇÅ, hf‚ÇÇ, hf‚ÇÉ‚ü©,
      refine ‚ü®Œª i hi, (hf‚ÇÅ _ hi).2, hf‚ÇÇ, Œª i, _, _‚ü©,
      { cases lt_or_le i t,
        { apply (hf‚ÇÅ _ ‚Äπ_‚Ä∫).1 },
        rw hf‚ÇÇ _ h,
        simp },
      intros i j h,
      wlog : i ‚â§ j using i j,
      { cases lt_or_le j t,
        { exact hf‚ÇÉ i (case.trans_lt h_1) j ‚Äπ_‚Ä∫ h },
        rw hf‚ÇÇ j h_1,
        apply disjoint_empty_right },
      exact (this h.symm).symm },
    { rintro ‚ü®hf‚ÇÅ, hf‚ÇÇ, hf‚ÇÉ, hf‚ÇÑ‚ü©,
      exact ‚ü®Œª i hi, ‚ü®hf‚ÇÉ _, hf‚ÇÅ _ hi‚ü©, hf‚ÇÇ, Œª i _ j _, hf‚ÇÑ i j‚ü© }
  end

  lemma partitions_on_zero {s : finset Œ±} {m : ‚Ñï} :
    partitions_on s m 0 = {Œª _, ‚àÖ} :=
  begin
    ext,
    split,
    { rw mem_partitions_on,
      intro h,
      rcases h with ‚ü®h1, h2, h3‚ü©,
      norm_num,
      ext1,
      have hx : 0 ‚â§ x := by linarith,
      exact h2 x hx, },
    { intro h,
      rw mem_partitions_on,
      refine ‚ü®_, _, _‚ü©,
      { intros i hi,
        norm_num at h,
        simp only [h, empty_subset, card_empty, true_and],
        linarith, },
      { intros i hi,
        norm_num at h,
        rw h, },
      { intros i hi j hj hij,
        norm_num at h,
        simp only [h, disjoint_empty_right], }, },
  end

  lemma subset_of_mem_partitions_on {m t : ‚Ñï} {s : finset Œ±} {f : ‚Ñï ‚Üí finset Œ±}
    (hf : f ‚àà partitions_on s m t) :
    (range t).bUnion f ‚äÜ s :=
  begin
    simp only [bUnion_subset, finset.mem_range],
    intros i hi,
    exact (((mem_partitions_on f).1 hf).1 i hi).1,
  end

  lemma card_bUnion_of_mem_partitions_on {m t : ‚Ñï} {s : finset Œ±} {f : ‚Ñï ‚Üí finset Œ±}
    (hf : f ‚àà partitions_on s m t) :
    ((range t).bUnion f).card = m * t :=
  begin
    rw mem_partitions_on at hf,
    rw [card_bUnion, mul_comm, finset.sum_const_nat, card_range],
    { intros i hi,
      exact (hf.1 i (by simpa using hi)).2 },
    simpa only [mem_range] using hf.2.2,
  end

  def split_partition (f : ‚Ñï ‚Üí finset Œ±) : (‚Ñï ‚Üí finset Œ±) √ó finset Œ± := (Œª i, f (i+1), f 0)
  lemma split_partition_bij :
    function.bijective (split_partition : (‚Ñï ‚Üí finset Œ±) ‚Üí (‚Ñï ‚Üí finset Œ±) √ó finset Œ±) :=
  begin
    split,
    { intros f‚ÇÅ f‚ÇÇ h,
      ext n : 1,
      simp only [split_partition, prod.mk.inj_iff] at h,
      cases n,
      { exact h.2 },
      have := function.funext_iff.1 h.1 n,
      exact this },
    rintro ‚ü®f‚ÇÅ, f‚ÇÇ‚ü©,
    exact ‚ü®Œª n, nat.cases_on n f‚ÇÇ f‚ÇÅ, rfl‚ü©,
  end

  lemma split_partition_strong_surj {s : finset Œ±} {m t} (f‚ÇÅ : ‚Ñï ‚Üí finset Œ±) (f‚ÇÇ : finset Œ±)
    (hf‚ÇÅ : f‚ÇÅ ‚àà partitions_on s m t) (hf‚ÇÇ : f‚ÇÇ ‚äÜ s \ (range t).bUnion f‚ÇÅ)
    (hf‚ÇÉ : f‚ÇÇ.card = m) :
    ‚àÉ f : ‚Ñï ‚Üí finset Œ±, f ‚àà partitions_on s m (t + 1) ‚àß
      (split_partition f).fst = f‚ÇÅ ‚àß (split_partition f).snd = f‚ÇÇ :=
  begin
    refine ‚ü®Œª n, nat.cases_on n f‚ÇÇ f‚ÇÅ, _, rfl, rfl‚ü©,
    rw mem_partitions_on,
    refine ‚ü®_, _, _‚ü©,
    { intros i hi,
      refine ‚ü®_, _‚ü©,
      { cases i,
        { dsimp only,
          exact subset_trans hf‚ÇÇ (finset.sdiff_subset s _), },
        { dsimp only,
          have hit : i < t,
          { rw nat.succ_eq_add_one at hi,
            linarith, },
          rw mem_partitions_on at hf‚ÇÅ,
          rcases hf‚ÇÅ with ‚ü®h1, h2, h3‚ü©,
          exact (h1 i hit).1, }, },
      { cases i,
        { dsimp only,
          exact hf‚ÇÉ, },
        { dsimp only,
          have hit : i < t,
          { rw nat.succ_eq_add_one at hi, linarith, },
          rw mem_partitions_on at hf‚ÇÅ,
          rcases hf‚ÇÅ with ‚ü®h1, h2, h3‚ü©,
          exact (h1 i hit).2, }, }, },
    { intros i hi,
      cases i,
      { dsimp only,
        exfalso,
        linarith, },
      { dsimp only,
        have hit : i ‚â• t,
        { rw nat.succ_eq_add_one at hi, linarith, },
        rw mem_partitions_on at hf‚ÇÅ,
        rcases hf‚ÇÅ with ‚ü®h1, h2, h3‚ü©,
        exact h2 i hit, }, },
    { intros i hi j hj hij,
      rw mem_partitions_on at hf‚ÇÅ,
      rcases hf‚ÇÅ with ‚ü®h1, h2, h3‚ü©,
      cases i,
      { cases j,
        { exfalso,
          norm_cast at hij, },
        { dsimp only,
          have hjt : j < t,
          { rw nat.succ_eq_add_one at hj, linarith, },
          suffices : disjoint f‚ÇÇ ((range t).bUnion f‚ÇÅ),
          { have h : f‚ÇÅ j ‚äÜ (range t).bUnion f‚ÇÅ,
            { apply finset.subset_bUnion_of_mem,
              exact mem_range.mpr hjt, },
            apply finset.disjoint_of_subset_right h,
            exact this, },
          { apply finset.disjoint_of_subset_left hf‚ÇÇ,
            exact finset.sdiff_disjoint, }, }, },
      { cases j,
        { dsimp only,
          have hit : i < t,
          { rw nat.succ_eq_add_one at hi, linarith, },
          suffices : disjoint ((range t).bUnion f‚ÇÅ) f‚ÇÇ,
          { have h : f‚ÇÅ i ‚äÜ (range t).bUnion f‚ÇÅ,
            { apply finset.subset_bUnion_of_mem,
              exact mem_range.mpr hit, },
            apply finset.disjoint_of_subset_left h,
            exact this, },
          { apply finset.disjoint_of_subset_right hf‚ÇÇ,
            exact finset.disjoint_sdiff, }, },
        { dsimp only,
          have hij' : i ‚â† j,
          { simpa only [ne.def, add_left_inj] using hij, },
          have hi' : i < t,
          { rw nat.succ_eq_add_one at hi, linarith, },
          have hj' : j < t,
          { rw nat.succ_eq_add_one at hj, linarith, },
          exact h3 i hi' j hj' hij', }, }, },
  end

  -- state and prove that if `f ‚àà partitions_on s m (t+1)`, then these three are true
  -- (split_partition f).1 ‚àà partitions_on s m t
  -- (split_partition f).2 ‚äÜ s \ (range t).bUnion (split_partition f).1
  -- (split_partition f).2.card = m

  lemma card_partitions_on {s : finset Œ±} {m t : ‚Ñï} :
    (partitions_on s m t).card = ‚àè i in range t, (s.card - m * i).choose m :=
  begin
    induction t with t ih,
    { rw [finset.range_zero, finset.prod_empty, partitions_on_zero, finset.card_singleton] },
    rw [finset.prod_range_succ, ‚Üêih],
    let extension : finset (Œ£ (i : ‚Ñï ‚Üí finset Œ±), finset Œ±) :=
      (partitions_on s m t).sigma (Œª f, (s \ (range t).bUnion f).powerset_len m),
    have : extension.card = (partitions_on s m t).card * (s.card - m * t).choose m,
    { simp only [finset.card_sigma, finset.card_powerset_len],
      have : ‚àÄ f ‚àà partitions_on s m t,
        (s \ (range t).bUnion f).card.choose m = (s.card - m * t).choose m,
      { intros f hf,
        have : (range t).bUnion f ‚äÜ s,
        { apply subset_of_mem_partitions_on hf },
        rw [card_sdiff this, card_bUnion_of_mem_partitions_on hf] },
      rw [sum_congr rfl this, sum_const, smul_eq_mul] },
    rw ‚Üêthis,
    refine card_congr (Œª f _, ‚ü®(split_partition f).1, (split_partition f).2‚ü©) _ _ _,
    { intros f hf,
      rw mem_partitions_on' at hf,
      simp only [extension, mem_sigma, mem_powerset_len],
      refine ‚ü®_, _, _‚ü©,
      { rcases hf with ‚ü®hf1, hf2, hf3‚ü©,
        rw mem_partitions_on,
        refine ‚ü®_, _, _‚ü©,
        { intros i hi,
          refine ‚ü®_, _‚ü©,
          { apply hf3.1, },
          { apply hf1,
            exact nat.succ_lt_succ hi, }, },
        { intros i hi,
          apply hf2,
          exact nat.succ_le_succ hi, },
        { intros i hi j hj hij,
          apply hf3.2,
          exact (add_ne_add_left 1).mpr hij, }, },
      { change f 0 ‚äÜ s \ (range t).bUnion (split_partition f).fst,
        rw finset.subset_iff,
        intros x hx,
        rw finset.mem_sdiff,
        have hfs : f 0 ‚äÜ s,
        { apply hf.2.2.1, },
        simp only [finset.mem_of_subset hfs hx, mem_bUnion, mem_range, exists_prop, not_exists, not_and, true_and],
        intros i hi,
        by_contra c,
        have hfd : disjoint (f 0) ((split_partition f).fst i),
        { apply hf.2.2.2,
          linarith, },
        rw finset.disjoint_iff_ne at hfd,
        specialize hfd x hx x c,
        apply hfd, refl, },
      { apply hf.1,
        exact ne_zero.pos (nat.succ t), }, },
    { rintro f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ,
      simp only [heq_iff_eq, and_imp],
      intros h‚ÇÅ h‚ÇÇ,
      refine split_partition_bij.1 _,
      ext : 1; assumption },
    rintro ‚ü®f‚ÇÅ, f‚ÇÇ‚ü©,
    simp only [mem_sigma, sigma.mk.inj_iff, heq_iff_eq, exists_prop, and_imp,
      mem_powerset_len],
    apply split_partition_strong_surj,
  end

  lemma card_partition_fix_first {s : finset Œ±} {m t : ‚Ñï} {V : finset Œ±}
    (hV : V.card = m) (hV' : V ‚äÜ s) :
    ((partitions_on s m (t + 1)).filter (Œª f : ‚Ñï ‚Üí finset Œ±, f 0 = V)).card =
      (partitions_on (s \ V) m t).card :=
  begin
    refine card_congr (Œª f _, (split_partition f).1) _ _ _,
    { simp only [mem_filter, and_imp],
      rintro f hf rfl,
      rw [mem_partitions_on'] at hf ‚ä¢,
      refine ‚ü®Œª i hi, hf.1 _ (by simpa using hi), Œª i hi, hf.2.1 _ (by simpa using hi),
        _, Œª i j h, hf.2.2.2 (i+1) (j+1) (by simpa using h)‚ü©,
      intros i x hx,
      rw [mem_sdiff],
      exact ‚ü®hf.2.2.1 _ hx, disjoint_left.1 (hf.2.2.2 (i+1) 0 (nat.succ_ne_zero _)) hx‚ü© },
    { simp only [mem_filter, and_imp],
      intros f‚ÇÅ f‚ÇÇ hf‚ÇÅ h‚ÇÅ hf‚ÇÇ h‚ÇÇ h,
      refine split_partition_bij.1 _,
      ext : 1,
      { exact h },
      rw [split_partition, split_partition],
      exact h‚ÇÅ.trans h‚ÇÇ.symm },
    { simp only [mem_filter, exists_prop],
      intros f hf,
      refine ‚ü®Œª n, nat.cases_on n V f, ‚ü®_, rfl‚ü©, rfl‚ü©,
      rw [mem_partitions_on'],
      sorry -- xialu
      },
  end

  lemma partition_swap {s : finset Œ±} {m t : ‚Ñï} {f : ‚Ñï ‚Üí finset Œ±} (hf : f ‚àà partitions_on s m t)
    {i j : ‚Ñï} (hi : i < t) (hj : j < t) :
    f ‚àò equiv.swap i j ‚àà partitions_on s m t :=
  begin
    rw mem_partitions_on' at hf ‚ä¢,
    refine ‚ü®Œª k hk, hf.1 _ _, Œª k hk, hf.2.1 _ _, Œª k, hf.2.2.1 _, Œª _ _ h, hf.2.2.2 _ _ _‚ü©,
    { rcases eq_or_ne k i with rfl | ik,
      { rwa equiv.swap_apply_left },
      rcases eq_or_ne k j with rfl | jk,
      { rwa equiv.swap_apply_right },
      rwa equiv.swap_apply_of_ne_of_ne ik jk },
    { rwa equiv.swap_apply_of_ne_of_ne (hi.trans_le hk).ne' (hj.trans_le hk).ne' },
    { simpa using h },
  end

  lemma card_partition_fix_swap {s : finset Œ±} {m t : ‚Ñï} {V : finset Œ±} {i j : ‚Ñï}
    (hi : i < t) (hj : j < t) :
    ((partitions_on s m t).filter (Œª f : ‚Ñï ‚Üí finset Œ±, f i = V)).card =
      ((partitions_on s m t).filter (Œª f : ‚Ñï ‚Üí finset Œ±, f j = V)).card :=
  begin
    refine card_congr (Œª f _, f ‚àò equiv.swap i j) _ _ _,
    { simp only [mem_filter, function.comp_app, equiv.swap_apply_right, and_imp],
      intros f hf hf',
      refine ‚ü®_, hf'‚ü©,
      apply partition_swap hf hi hj },
    { intros f‚ÇÅ f‚ÇÇ _ _ h,
      refine function.surjective.injective_comp_right _ h,
      apply equiv.surjective },
    intros f hf,
    simp only [mem_filter, exists_prop, and_assoc] at hf ‚ä¢,
    refine ‚ü®f ‚àò equiv.swap i j, partition_swap hf.1 hi hj, _, _‚ü©,
    { simpa using hf.2 },
    ext x : 1,
    simp [equiv.swap_apply_self],
  end

  lemma card_partition_fix' {s : finset Œ±} {m t : ‚Ñï} {V : finset Œ±}
    (hV : V.card = m) (hV' : V ‚äÜ s) {i : ‚Ñï} (hi : i < t + 1) :
    ((partitions_on s m (t + 1)).filter (Œª f : ‚Ñï ‚Üí finset Œ±, f i = V)).card *
      s.card.choose m =
      (partitions_on s m (t + 1)).card :=
  begin
    rw [card_partition_fix_swap hi nat.succ_pos', card_partition_fix_first hV hV',
      card_partitions_on, card_partitions_on, card_sdiff hV', hV, finset.prod_range_succ', mul_zero,
      nat.sub_zero],
    simp only [mul_add_one, nat.sub_sub, add_comm],
  end

  lemma card_partition_fix {s : finset Œ±} {m t : ‚Ñï} {V : finset Œ±}
    (hV : V.card = m) (hV' : V ‚äÜ s) {i : ‚Ñï} (hi : i < t) :
    ((partitions_on s m t).filter (Œª f : ‚Ñï ‚Üí finset Œ±, f i = V)).card * s.card.choose m =
      (partitions_on s m t).card :=
  begin
    cases t,
    { simpa using hi },
    apply card_partition_fix' hV hV' hi,
  end

end partition

def shadow (G : finset (finset Œ±)) (U : finset Œ±) : finset (finset Œ±) := G.filter (Œª Y, Y ‚äÜ U)

lemma shadow_subset : shadow G U ‚äÜ G :=
begin
  unfold shadow,
  simp only [finset.filter_subset],
  -- an alternative is
  -- rw finset.subset_iff,
  -- intros x h,
  -- refine finset.mem_of_mem_filter _ h,
end

-- defined for uniform distribution
def spread (Œµ : ‚Ñù) (U : finset (finset Œ±)) : Prop :=
‚àÄ (Z : finset Œ±), (finset.card (U.filter (Œª u, Z ‚äÜ u)) : ‚Ñù) ‚â§ Œµ ^ Z.card * U.card

----- Lemmas for spred_iff_ratio ---------------------
def spr_1 (a b c : ‚Ñù ) (hc : 0 < c ): (a‚â§ b) ‚Üí (a/c ‚â§  b / c) :=
begin
  intros h, exact (div_le_div_right hc).mpr h,
end

lemma zer_zerco : 0 = ((0:‚Ñï ): ‚Ñù )  := by simp
----------------------------------------------

lemma spread_iff_ratio (Œµ : ‚Ñù) (U : finset (finset Œ±)) {he : 0 ‚â§ Œµ } :
  spread Œµ U ‚Üî ‚àÄ (Z : finset Œ±), (finset.card (U.filter (Œª u, Z ‚äÜ u)) : ‚Ñù) / U.card ‚â§ Œµ ^ Z.card :=
begin
  split,
  {
    unfold spread,
    intros h Z,
    cases nat.eq_zero_or_pos U.card, --patter match wrt U.card

    { --When U.card = 0
    have zz  : ‚àÄ r : ‚Ñù ,  r / (0: ‚Ñù ) = 0 := Œª r, div_zero r,
    rw h_1,

    rw ‚Üê zer_zerco,
    rw zz,
    exact pow_nonneg he Z.card,
    },

    { -- When U.card > 0
    specialize h Z,

    have hUcard : 0 < (U.card : ‚Ñù ), exact nat.cast_pos.mpr h_1,

    convert spr_1 ‚Üë((filter (Œª (u : finset Œ±), Z ‚äÜ u) U).card)  (Œµ^(Z.card) * ‚Üë(U.card)) ‚Üë(U.card) (nat.cast_pos.mpr h_1) h,
    symmetry,
    apply mul_div_cancel,
    exact ne_of_gt ( nat.cast_pos.mpr h_1),
    }
  },

  {
    unfold spread,
    intros h Z,
    specialize h Z,

    have hUcard : 0 ‚â§ (U.card : ‚Ñù ) :=
    begin
      rw zer_zerco,
      exact nat.cast_le.mpr(zero_le (U.card )),
    end,

    have H := mul_le_mul_of_nonneg_right h hUcard,

    cases nat.eq_zero_or_pos U.card,
    { -- When U.card = 0
      have fil_zero : (filter (Œª (u : finset Œ±), Z ‚äÜ u) U).card =0,
      {
        apply nat.eq_zero_of_le_zero,
        rw ‚Üê h_1,
        apply finset.card_le_of_subset,
        apply finset.filter_subset,
      },

      rw fil_zero, rw h_1, simp,
    },

    { -- When U.card > 0
      rw div_mul_cancel ‚Üë((filter (Œª (u : finset Œ±), Z ‚äÜ u) U).card) at H,
      exact H,
      exact ne_of_gt ( nat.cast_pos.mpr h_1),
    }

  }
end

def to_antichain (G : finset (finset Œ±)) : finset (finset Œ±) :=
G.filter (Œª A, ‚àÄ B ‚àà G, B ‚äÜ A ‚Üí B = A)

lemma ssubset_thing {Œ≤ : Type*} {X Y : finset Œ≤} : (¬¨ Y ‚äÇ X) ‚Üî (Y ‚äÜ X ‚Üí Y = X) :=
begin
  split,
  { intros hY hYX,
    by_contra h,
    have hp : Y ‚äÇ X,
    { rw finset.ssubset_iff_subset_ne, split, exact hYX, exact h, },
    apply hY,
    exact hp, },
  { intros hY hYX,
    cases hYX with h1 h2,
    specialize hY h1,
    finish, },
end

lemma to_antichain_eq : to_antichain G = G.filter (Œª A, ‚àÄ B ‚àà G, ¬¨ B ‚äÇ A) :=
begin
  simpa only [ssubset_thing],
end

lemma to_antichain_subset : to_antichain G ‚äÜ G :=
begin
  apply filter_subset,
end

lemma is_antichain_to_antichain : is_antichain (‚äÜ) (to_antichain G : set (finset Œ±)) :=
begin
  intros A h1 B h2 h3 h4,
  unfold to_antichain at h1,
  rw finset.mem_coe at h1,
  rw finset.mem_filter at h1,
  cases h1 with h5 h6,
  specialize h6 B,
  unfold to_antichain at h2,
  rw finset.mem_coe at h2,
  rw finset.mem_filter at h2,
  cases h2 with h7 h8,
  specialize h8 A,
  have h9 := h8(h5),
  have h11 := h9(h4),
  apply h3,
  exact h11,
end

-- mathematically solvable by induction on cardinality of A
lemma contains_subset {A} (hA : A ‚àà G) : ‚àÉ B ‚àà to_antichain G, B ‚äÜ A :=
begin
  set n := finset.card A with h,
  clear_value n,
  induction n using nat.strong_induction_on with n ih generalizing A,
  -- for n being zero, empty set A must be in G' as there is no proper subset of an empty set
  -- have hA' : A = ‚àÖ,
  -- { rw ‚Üê finset.card_eq_zero, linarith, },
  -- use A,
  -- split,
  -- { unfold to_antichain,
  --   rw finset.mem_filter,
  --   split, exact hA,
  --   intros B hB hBA,
  --   suffices : B = ‚àÖ,
  --   rw hA', exact this,
  --   rw hA' at hBA,
  --   rwa finset.subset_empty at hBA, },
  -- { simp only [subset_refl], },
  -- for inductive step, we consider two cases, A in G' or otherwise
  have q : A ‚àà to_antichain G ‚à® A ‚àâ to_antichain G := by finish,
  cases q with h1 h2,
  -- for A in G', use A and done
  use A,
  split, exact h1,
  simp only [subset_refl],
  -- for A in G, there exists a proper subset of A in G, named A', |A'| < |A|, apply inductive hypothesis
  have p : ‚àÉ (C : finset Œ±), C ‚àà G ‚àß C ‚äÇ A,
  { by_contra hp,
    push_neg at hp,
    apply h2,
    unfold to_antichain,
    rw finset.mem_filter,
    split, exact hA,
    intros B hB,
    rw ‚Üê ssubset_thing,
    specialize hp B hB,
    exact hp, },
  rcases p with ‚ü®C, ‚ü®p1, p2‚ü©‚ü©,
  have hC : C.card < n,
  { rw h,
    refine finset.card_lt_card p2, },
  suffices : ‚àÉ (B : finset Œ±) (H : B ‚àà to_antichain G), B ‚äÜ C,
  { rcases this with ‚ü®B, ‚ü®hB1, hB2‚ü©‚ü©,
    use B,
    split, exact hB1,
    refine subset_trans hB2 _,
    rw subset_iff_ssubset_or_eq,
    left, exact p2, },
  { specialize ih C.card hC p1,
    simp only [eq_self_iff_true, exists_prop, forall_true_left] at ih,
    cases ih with B hB,
    use B,
    exact hB, },
end

lemma exists_subset_minimal {S : finset (finset Œ±)} (hS : S.nonempty) :
  ‚àÉ X ‚àà S, ‚àÄ Y ‚àà S, Y ‚äÜ X ‚Üí Y = X :=
begin
  -- set M : finset (finset Œ±) := S.filter(Œª X : finset Œ±, ‚àÄ Y : finset Œ±, Y ‚àà S ‚Üí X.card ‚â§ Y.card),
  set T : finset (finset Œ±) := to_antichain S,
  -- claim T is non-empty
  have hT : T.nonempty,
  { have := finset.nonempty.bex hS,
    cases this with A hA,
    have := contains_subset hA,
    rcases this with ‚ü®B, ‚ü®hB1, hB2‚ü©‚ü©,
    simp only [finset.nonempty],
    use B,
    exact hB1, },
  have := finset.nonempty.bex hT,
  cases this with X hX,
  -- use X ‚àà T
  use X,
  simp only [T] at hX,
  unfold to_antichain at hX,
  rw finset.mem_filter at hX,
  exact hX,
end

variables {W : ‚Ñï ‚Üí finset Œ±} {i : ‚Ñï}

-- WARNING! : INDEXED DIFFERENTLY FROM THE PDF
-- we only care about this definition for 0 ‚â§ i < t
-- this is ùí¢ the function
def the_partial_function (W : ‚Ñï ‚Üí finset Œ±) (ùíÆ : finset (finset Œ±)) (t : ‚Ñï) : ‚Ñï ‚Üí finset (finset Œ±)
| i :=
    finset.image (Œª S, S \ (finset.range (i+1)).bUnion W) $
    @finset.filter _
      (Œª S, 2 ^ (t - i - 1) ‚â§ (S \ (finset.range (i+1)).bUnion W).card ‚àß
            (‚àÄ j < i, ‚àÄ X ‚àà the_partial_function j, ¬¨ X ‚äÜ S) ‚àß
            ‚àÄ S' ‚àà ùíÆ, S' \ (finset.range (i+1)).bUnion W ‚äÇ S \ (finset.range (i+1)).bUnion W ‚Üí
              ¬¨ ‚àÄ (j < i), ‚àÄ (X ‚àà the_partial_function j), ¬¨ X ‚äÜ S')
      (Œª S, @and.decidable _ _ _ (@and.decidable _ _ _ finset.decidable_dforall_finset))
      -- this decidability detour is *really weird*, it indicates something is bad in mathlib
      -- I think...
    ùíÆ

def the_function (W : ‚Ñï ‚Üí finset Œ±) (ùíÆ : finset (finset Œ±)) (t : ‚Ñï) :=
(finset.range t).bUnion (the_partial_function W ùíÆ t)

lemma bUnion_indep {i : ‚Ñï} (W‚ÇÅ W‚ÇÇ : ‚Ñï ‚Üí finset Œ±) (h : ‚àÄ j ‚â§ i, W‚ÇÅ j = W‚ÇÇ j) :
  (range (i+1)).bUnion W‚ÇÅ = (range (i+1)).bUnion W‚ÇÇ :=
begin
  ext x,
  simp only [finset.mem_range_succ_iff, finset.mem_bUnion],
  refine bex_congr (Œª j hj, _),
  rw h _ hj
end

lemma the_partial_function_indep {ùíÆ : finset (finset Œ±)} {t i : ‚Ñï} (W‚ÇÅ W‚ÇÇ : ‚Ñï ‚Üí finset Œ±)
  (h : ‚àÄ j ‚â§ i, W‚ÇÅ j = W‚ÇÇ j) :
  the_partial_function W‚ÇÅ ùíÆ t i = the_partial_function W‚ÇÇ ùíÆ t i :=
begin
  induction i using nat.strong_induction_on with i ih,
  -- change finset.image _ _ = finset.image _ _,
  -- -- induction i,
  rw [the_partial_function.equations._eqn_1 W‚ÇÇ, the_partial_function],
  rw [bUnion_indep W‚ÇÅ W‚ÇÇ h],
  have : ‚àÄ (p : finset Œ± ‚Üí Prop), (‚àÄ j < i, ‚àÄ X ‚àà the_partial_function W‚ÇÅ ùíÆ t j, p X) ‚Üî
    (‚àÄ j < i, ‚àÄ X ‚àà the_partial_function W‚ÇÇ ùíÆ t j, p X),
  { intro p,
    refine ball_congr (Œª j hj, _),
    rw ih j hj (Œª k hk, h _ (hk.trans hj.le)) },
  congr' 2,
  ext S,
  simp only [this],
end

lemma part_two_a_helper (ht : 1 ‚â§ t) (S) (h : ¬¨ S ‚äÜ (finset.range t).bUnion W) :
  2 ^ (t-1 - (t-1)) ‚â§ (S \ (finset.range (t-1 + 1)).bUnion W).card :=
begin
  have proof_subset : ‚àÄ x : finset Œ±, ‚àÄ y : finset Œ±, (x \ y).card = 0 ‚Üí x ‚äÜ y,
    {intros hx hy card,
    have proof_empty : hx \ hy = ‚àÖ := iff.elim_left finset.card_eq_zero card,
    have proof_final : hx ‚äÜ hy,
      {have temp1 := iff.elim_left finset.eq_empty_iff_forall_not_mem proof_empty,
      intros hx2 assump1,
      have assump2:hx2 ‚àâ hx \ hy := temp1 hx2,
      by_contra hnp,
      refine assump2 _,
      exact iff.elim_right (finset.mem_sdiff) (and.intro assump1 hnp),},
    exact proof_final,},
  have proof_card_zero : ‚àÄ x:‚Ñï, (¬¨ 1 ‚â§ x ) ‚Üí x = 0,
    {intro x,
    intro ineq,
    linarith,},
  have bound_simp : 1 ‚â§ (S \ (finset.range (t)).bUnion W).card,
    {by_contra bound2,
    exact h (proof_subset S ((finset.range (t)).bUnion W) (proof_card_zero (S \ (finset.range (t)).bUnion W).card bound2)),},
  have final : 2 ^ (t-1 - (t-1)) ‚â§ (S \ (finset.range (t-1 + 1)).bUnion W).card,
    {simp,
    have equality:t-1+1 = t, {linarith},
    rw equality,
    exact bound_simp,},
  exact final,
end
/-
lemma thm1_part_two (W : ‚Ñï ‚Üí finset Œ±) (ùíÆ : finset (finset Œ±)) (t : ‚Ñï) (ht : 1 ‚â§ t) :
  (‚àÉ S ‚àà ùíÆ, S ‚äÜ (range t).bUnion W) ‚à® ‚àÄ S ‚àà ùíÆ, ‚àÉ X ‚àà the_function W ùíÆ t, X ‚äÜ S :=
begin
  by_contra,
  have h := not_or_distrib.1 h,
  have not_sub_w := h.1,
  apply h.2,
  intros hs el_s,
  let set_s' := finset.filter (Œª Y, Y \ ((range t).bUnion W) ‚äÜ hs \ ((range t).bUnion W) ‚àß (‚àÄ (j:‚Ñï), j< t-1 ‚Üí ‚àÄ X:finset Œ±, X ‚àà the_partial_function W ùíÆ t j ‚Üí ¬¨ X ‚äÜ Y)) ùíÆ,
  by_contra assump,
  have non_empt : (‚àÉ x:finset Œ±, x ‚àà set_s'),
    {use hs,
    rw finset.mem_filter,
    split, {exact el_s,},
      {split, {apply finset.subset_of_eq, refl,},
        {intros j bound X in_g,
        by_contra,
        have assump_pf:‚àÉ x2 ‚àà the_function W ùíÆ t, x2 ‚äÜ hs,
          {use X,
          split,
            {rw the_function,
            rw finset.mem_bUnion,
            use j,
            split,
              {rw finset.mem_range,
              linarith,},
              {exact in_g,}},{exact h,}},
        exact assump assump_pf,}}},
  let rem_w := Œª (x:finset Œ±), x \ (range t).bUnion W,
  let set_s'_map := finset.image rem_w set_s',
  have non_empt_im:set_s'_map.nonempty := finset.nonempty.image non_empt rem_w,
  have ex_min := exists_subset_minimal non_empt_im,
  cases ex_min with X ex_min,
  cases ex_min with X_el ex_min,
  apply assump,
  use X,
  have X_w := finset.mem_image.1 X_el,
  cases X_w with a aw_eq_x,
  cases aw_eq_x with a_in_s' func_a_x,
  have rw_X:a\(range t).bUnion W = X,{exact func_a_x,},
  have equality:t-1+1 = t, {rw nat.sub_add_cancel ht},
  have a_in_s := finset.mem_of_mem_filter a a_in_s',
  split,
    {rw the_function,
    rw finset.mem_bUnion,
    use t-1,
    rw finset.mem_range,
    split, {linarith,},
      {rw the_partial_function,
      rw finset.mem_image,
      use a,
      split,
        {rw finset.mem_filter,
        refine ‚ü®_,_,_,_‚ü©,
          {exact a_in_s,},
          {have rw_not_sub_w,
            {have el_imply := ((not_exists.1 not_sub_w) a),
            have el_imply_clean := not_exists.1 el_imply,
            exact el_imply_clean a_in_s,},
          have pow2_eq : ‚àÄ (vr:‚Ñï), vr ‚â• 1 ‚Üí 2 ^ (vr-(vr-1)-1) = 2 ^ (vr-1 - (vr-1)),
          { intros vr ineq,
            rw [nat.sub_self, nat.sub_sub, nat.sub_add_cancel ineq, nat.sub_self] },
          rw (pow2_eq t ht),
          exact part_two_a_helper ht a rw_not_sub_w,},
          {exact (finset.mem_filter.1 a_in_s').2.2,},
          {rw equality,
          intros hs' hs'_in_s hs'_sub,
          have strict_sub_hs := finset.ssubset_of_ssubset_of_subset hs'_sub (finset.mem_filter.1 a_in_s').2.1,
          by_contra minset_prop,
          have sub_hs := (finset.ssubset_iff_subset_ne.1 strict_sub_hs).1,
          have fulfills_minset_prop := and.intro sub_hs minset_prop,
          have hs'_in_minset:hs' ‚àà set_s' := finset.mem_filter.2 (and.intro hs'_in_s fulfills_minset_prop),
          have hs'_w_in_minset_map:hs'\ (range t).bUnion W ‚àà set_s'_map,{apply finset.mem_image.2,use hs',use hs'_in_minset,},
          have s'_is_minset:hs'\ (range t).bUnion W = a\ (range t).bUnion W,
            {rw rw_X,
            have hs'_sub_x:hs'\ (range t).bUnion W ‚äÜ X,
              {rw eq.symm rw_X,
              exact (finset.ssubset_iff_subset_ne.1 hs'_sub).1,},
            exact ex_min (hs'\ (range t).bUnion W) hs'_w_in_minset_map hs'_sub_x,},
          exact (finset.ssubset_iff_subset_ne.1 hs'_sub).2 s'_is_minset,}},
        {rw equality,exact func_a_x,},},},
    {rw eq.symm rw_X,
    have a_w_sub_hs_w:a\ (range t).bUnion W ‚äÜ hs\ (range t).bUnion W := (finset.mem_filter.1 a_in_s').2.1,
    have hs_w_sub_hs: hs\ (range t).bUnion W ‚äÜ hs := finset.sdiff_subset hs ((range t).bUnion W),
    exact finset.subset.trans a_w_sub_hs_w hs_w_sub_hs,}
end-/


def sample_space (Œ± : Type*) [fintype Œ±] [decidable_eq Œ±] (m t : ‚Ñï) :=
partitions_on (finset.univ : finset Œ±) m t

def finset.expectation {Œ± M : Type*} [field M] (s : finset Œ±) (f : Œ± ‚Üí M) : M :=
(‚àë x in s, f x) / s.card

local notation (name := finset.expectation)
  `ùîº` binders ` in ` s `, ` r:(scoped:67 f, finset.expectation s f) := r

lemma expectation_eq {Œ± M : Type*} [field M] {s : finset Œ±} {f : Œ± ‚Üí M} :
  ùîº x in s, f x = ‚àë x in s, f x / s.card :=
by rw [finset.expectation, sum_div]

variables [fintype Œ±]

lemma thm1_part_one {m t : ‚Ñï} {ùíÆ : finset (finset Œ±)} {U : finset (finset Œ±)} {Œµ : ‚Ñù}
  (hm : 1 ‚â§ m) (ht : 1 ‚â§ t) (hŒµ : 0 < Œµ)
  (hS : ‚àÄ S ‚àà ùíÆ, finset.card S ‚â§ 2 ^ t) (hU : spread Œµ U)
  (h : ‚àÄ (R : finset Œ±) i < t,
    (((sample_space Œ± m t).filter (Œª (W : ‚Ñï ‚Üí finset Œ±), W i ‚äÜ R)).card : ‚Ñù) ‚â§
      ((64 * Œµ) ^ (m - R.card) / (fintype.card Œ±).choose R.card) * (sample_space Œ± m t).card) :
  ùîº W in sample_space Œ± m t, ùîº u in U, ((shadow (the_function W ùíÆ t) u).card : ‚Ñù) < 1 / 8 :=
begin
  sorry
end

lemma filter_const {Œ± : Type*} (p : Prop) [decidable p] (s : finset Œ±) :
  s.filter (Œª _, p) = if p then s else ‚àÖ :=
begin
  by_cases p,
  { rw [filter_true_of_mem (Œª _ _, h), if_pos h] },
  { rw [filter_false_of_mem (Œª _ _, h), if_neg h] },
end

lemma powerset_filter_subset {Œ± : Type*} [decidable_eq Œ±] (n : ‚Ñï) (s t : finset Œ±) :
  (powerset_len n s).filter (Œª i, i ‚äÜ t) = (powerset_len n (s ‚à© t)) :=
by { ext x, simp [mem_powerset_len, subset_inter_iff, and.right_comm] }

open_locale classical

lemma partitions_on_eq {s : finset Œ±} {m t} :
  partitions_on s m t = (s.powerset_len (m * t)).bUnion (Œª W, partitions_on W m t) :=
begin
  ext f,
  simp only [mem_bUnion, exists_prop, mem_powerset_len, and_assoc],
  split,
  { rintro hf,
    refine ‚ü®(range t).bUnion f, subset_of_mem_partitions_on hf, card_bUnion_of_mem_partitions_on hf,
      _‚ü©,
    simp only [mem_partitions_on],
    simp only [mem_partitions_on'] at hf,
    exact ‚ü®Œª i hi, ‚ü®subset_bUnion_of_mem _ (by simpa using hi), hf.1 _ hi‚ü©, hf.2.1,
      Œª _ _ _ _ h, hf.2.2.2 _ _ h‚ü© },
  rintro ‚ü®W, hW, hW', hf‚ü©,
  simp only [mem_partitions_on'] at hf ‚ä¢,
  exact ‚ü®hf.1, hf.2.1, Œª i, (hf.2.2.1 _).trans hW, hf.2.2.2‚ü©,
end

lemma partitions_on_inj_on {m t : ‚Ñï} {W‚ÇÅ W‚ÇÇ : finset Œ±}
  (hW‚ÇÅ : W‚ÇÅ.card = m * t) (hW‚ÇÇ : W‚ÇÇ.card = m * t) {f} :
  f ‚àà partitions_on W‚ÇÅ m t ‚Üí f ‚àà partitions_on W‚ÇÇ m t ‚Üí W‚ÇÅ = W‚ÇÇ :=
begin
  intros hf‚ÇÅ hf‚ÇÇ,
  rw [‚Üêeq_of_subset_of_card_le (subset_of_mem_partitions_on hf‚ÇÅ),
      ‚Üêeq_of_subset_of_card_le (subset_of_mem_partitions_on hf‚ÇÇ)],
  { rw [hW‚ÇÇ, card_bUnion_of_mem_partitions_on hf‚ÇÇ] },
  { rw [hW‚ÇÅ, card_bUnion_of_mem_partitions_on hf‚ÇÅ] },
end

lemma random_partition (R : finset Œ±) {m i : ‚Ñï} (hi : i < t) :
  (fintype.card Œ±).choose m *
    ((sample_space Œ± m t).filter (Œª Ws : ‚Ñï ‚Üí finset Œ±, Ws i ‚äÜ R)).card =
      R.card.choose m * (sample_space Œ± m t).card :=
begin
  have : ‚àÄ (Ws : ‚Ñï ‚Üí finset Œ±), Ws ‚àà sample_space Œ± m t ‚Üí
    Ws i ‚àà powerset_len m (univ : finset Œ±),
  { simp only [mem_powerset_len_univ_iff, sample_space, mem_partitions_on', and_imp],
    intros f hf _ _ _,
    apply hf _ hi },
  have := @finset.bUnion_filter_eq_of_maps_to _ _ _ _ (sample_space Œ± m t)
    (univ.powerset_len m) (Œª f, f i) this,
  conv_lhs {rw ‚Üêthis},
  rw [filter_bUnion, finset.card_bUnion],
  { have : ‚àÄ x ‚àà powerset_len m (univ : finset Œ±),
      (((sample_space Œ± m t).filter (Œª (Ws : ‚Ñï ‚Üí finset Œ±), Ws i = x)).filter
        (Œª (Ws : ‚Ñï ‚Üí finset Œ±), Ws i ‚äÜ R)).card =
      (((sample_space Œ± m t).filter (Œª (Ws : ‚Ñï ‚Üí finset Œ±), Ws i = x)).filter
        (Œª _, x ‚äÜ R)).card,
    { intros x hx,
      rw [filter_filter, filter_filter],
      congr' 2,
      ext f,
      simp { contextual := tt } },
    rw [sum_congr rfl this],
    simp only [filter_const, apply_ite finset.card, card_empty, sample_space],
    rw [‚Üêsum_filter],
    have : ‚àë (a : finset Œ±) in filter (Œª (a : finset Œ±), a ‚äÜ R) (powerset_len m univ),
      (fintype.card Œ±).choose m *
        (filter (Œª (Ws : ‚Ñï ‚Üí finset Œ±), Ws i = a) (partitions_on univ m t)).card =
      ‚àë (a : finset Œ±) in powerset_len m R, (partitions_on univ m t).card,
    { apply finset.sum_congr _ _,
      { convert (powerset_filter_subset m univ R).trans _,
        rw univ_inter },
      intros x hx,
      rw [mul_comm, ‚Üêcard_univ, card_partition_fix _ (subset_univ _) hi],
      rw mem_powerset_len at hx,
      exact hx.2 },
    rw [mul_sum, this, sum_const, smul_eq_mul, card_powerset_len] },
  simp only [mem_powerset_len_univ_iff],
  intros W‚ÇÅ hW‚ÇÅ W‚ÇÇ hW‚ÇÇ h,
  rw finset.disjoint_left,
  simp only [mem_filter, not_and, and_imp],
  rintro f _ rfl _ _ rfl,
  cases h rfl
end

lemma cor1 {m t : ‚Ñï} {ùíÆ : finset (finset Œ±)} {U : finset (finset Œ±)} {Œµ : ‚Ñù}
  (hm : 1 ‚â§ m) (ht : 1 ‚â§ t) (hŒµ : 0 < Œµ) (hn : Œµ ‚â§ m / 64 * fintype.card Œ±)
  (hS : ‚àÄ S ‚àà ùíÆ, finset.card S ‚â§ 2 ^ t) (hU : spread Œµ U) :
  ùîº Ws in sample_space Œ± m t,
    ùîº u in U, ((shadow (the_function Ws ùíÆ t) u).card : ‚Ñù) < 1 / 8 ‚àß
  ‚àÄ W, (‚àÉ S ‚àà ùíÆ, S ‚äÜ W) ‚à® ‚àÄ Ws ‚àà partitions_on W m t, ‚àÄ S ‚àà ùíÆ, ‚àÉ X ‚àà the_function Ws ùíÆ t, X ‚äÜ S :=
begin
  sorry
end

-- the things from here down are Bhavik's proofs of stuff which is now (probably) not necessary
-- but I'm keeping them just in case they turn out useful

-- lemma part_one_one_easy_bit (R : finset Œ±) (h : ¬¨ ‚àÉ T ‚àà the_partial_function W ùíÆ t i, T ‚äÜ R) :
--   ((the_partial_function W ùíÆ t i).filter (Œª T, R = T ‚à™ W i)).card ‚â§ 2 ^ (2 ^ (t - i)) :=
-- begin
--   rw [finset.filter_false_of_mem, card_empty],
--   { apply nat.zero_le _ },
--   rintro T hT rfl,
--   exact h ‚ü®T, hT, subset_union_left _ _‚ü©,
-- end

-- lemma part_one_one_other_easy_bit (R : finset Œ±) (hR : ¬¨ W i ‚äÜ R) :
--   ((the_partial_function W ùíÆ t i).filter (Œª T, R = T ‚à™ W i)).card ‚â§ 2 ^ (2 ^ (t - i)) :=
-- begin
--   rw [finset.filter_false_of_mem, card_empty],
--   { apply nat.zero_le _ },
--   rintro T hT rfl,
--   exact hR (subset_union_right _ _),
-- end

-- lemma part_one_one_hard_bit_first_step {R : finset Œ±} (hR : W i ‚äÜ R)
--   (h : ‚àÉ T ‚àà the_partial_function W ùíÆ t i, T ‚äÜ R) :
--   (ùíÆ.filter (Œª S, S \ (finset.range i).bUnion W ‚äÜ R ‚àß
--     S \ (finset.range (i + 1)).bUnion W ‚àà the_partial_function' W ùíÆ t i)).nonempty :=
-- begin
--   obtain ‚ü®T, hT‚ÇÅ, hT‚ÇÇ‚ü© := h,
--   rw [the_partial_function_eq] at hT‚ÇÅ,
--   replace hT‚ÇÅ := to_antichain_subset hT‚ÇÅ,
--   simp only [the_partial_function', mem_filter, finset.mem_image, exists_prop, and_assoc,
--     finset.nonempty] at hT‚ÇÅ ‚ä¢,
--   obtain ‚ü®S, hS‚ÇÅ, hS‚ÇÇ, rfl‚ü© := hT‚ÇÅ,
--   refine ‚ü®S, hS‚ÇÅ, _, S, hS‚ÇÅ, hS‚ÇÇ, rfl‚ü©,
--   rw [range_succ, finset.bUnion_insert, sdiff_union_distrib] at hT‚ÇÇ,
--   intros x hx,
--   by_cases x ‚àà W i,
--   { apply hR h },
--   apply hT‚ÇÇ,
--   simp only [finset.mem_inter, mem_sdiff, finset.mem_bUnion, finset.mem_range, exists_prop,
--     not_exists, not_and] at hx ‚ä¢,
--   tauto
-- end


-- #check cond_count
-- #check matrix.vec_cons
-- lemma part_one_one (R : finset Œ±)  (hS : ‚àÄ S ‚àà ùíÆ, finset.card S ‚â§ 2 ^ t) :
--   ((the_partial_function W ùíÆ t i).filter (Œª T, R = T ‚à™ W i)).card ‚â§ 2 ^ (2 ^ (t - i)) :=
-- begin
--   -- by_cases h‚ÇÅ : W i ‚äÜ R,
--   -- { by_cases h‚ÇÇ : ‚àÉ T ‚àà the_partial_function W ùíÆ t i, T ‚äÜ R,
--   --   { apply part_one_one_hard_bit _ h‚ÇÅ hS h‚ÇÇ },
--   --   apply part_one_one_easy_bit _ h‚ÇÇ },
--   -- apply part_one_one_other_easy_bit _ h‚ÇÅ,
-- end

--#exit
/-
-- variables {Œ© : Type*} [measurable_space Œ©] {Œº : measure Œ©}

lemma exists_uniform' (Œµ : ‚Ñù) (U : finset (finset Œ±)) : ‚àÉ (Œº : measure (finset Œ±))
  (UU : finset Œ± ‚Üí finset Œ±), pdf.is_uniform UU (U : set (finset Œ±)) Œº measure.count :=
‚ü®_, _, exists_uniform _ _ measurable_space.measurable_set_top‚ü©


--notation X ` ‚äà ` Y := ¬¨ (X ‚äÜ Y)
-/
-------------------------------------------------------------------------

-- noncomputable def lhs_sample_space (m t : ‚Ñï) (U : finset (finset Œ±)) :=
-- U.product
--   (finset.sigma (((finset.univ : finset Œ±).powerset_len (m * t)).bUnion (Œª W, partitions_on W m t)) $
--     (Œª Ws, the_function Ws ùíÆ t))

--   #check lhs_sample_space

lemma lem2_part1 {m t : ‚Ñï} {ùíÆ : finset (finset Œ±)} {U : finset (finset Œ±)} {Œµ : ‚Ñù}   (hm : 1 ‚â§ m)
  (ht : 1 ‚â§ t) (hŒµ : 0 < Œµ) (hn : Œµ ‚â§ m / 64 * fintype.card Œ±)
  (hS : ‚àÄ S ‚àà ùíÆ, finset.card S ‚â§ 2 ^ t) (hU : spread Œµ U) :
  (((sample_space Œ± m t).filter
      (Œª Ws, ‚àÄ S ‚àà ùíÆ, (shadow (the_function Ws ùíÆ t) S).nonempty)).card : ‚Ñù) /
    (sample_space Œ± m t).card ‚â§
  ùîº Ws in sample_space Œ± m t, ùîº u in U, ((shadow (the_function Ws ùíÆ t) u).card : ‚Ñù) :=
begin
  sorry
end

lemma lem2_part2 {m t : ‚Ñï} {ùíÆ : finset (finset Œ±)} {U : finset (finset Œ±)} {Œµ : ‚Ñù}   (hm : 1 ‚â§ m)
  (ht : 1 ‚â§ t) (hŒµ : 0 < Œµ) (hn : Œµ ‚â§ m / 64 * fintype.card Œ±)
  (hS : ‚àÄ S ‚àà ùíÆ, finset.card S ‚â§ 2 ^ t) (hU : spread Œµ U) :
  (card (((univ : finset Œ±).powerset_len (m * t)).filter (Œª w, ‚àÄT ‚àà ùíÆ, ¬¨ T ‚äÜ w)) : ‚Ñù) /
    ((fintype.card Œ±).choose (m*t)) ‚â§
  (((sample_space Œ± m t).filter
    (Œª Ws, ‚àÄ S ‚àà ùíÆ, (shadow (the_function Ws ùíÆ t) S).nonempty)).card : ‚Ñù) /
  (sample_space Œ± m t).card :=
begin
  have : ‚àÄ (Ws : ‚Ñï ‚Üí finset Œ±),
    Ws ‚àà sample_space Œ± m t ‚Üí (‚àÄ S ‚àà ùíÆ, ¬¨ S ‚äÜ (range t).bUnion Ws) ‚Üí
      ‚àÄ S ‚àà ùíÆ, (shadow (the_function Ws ùíÆ t) S).nonempty,
  { intros Ws h h' S hS',
    obtain ‚ü®X, hX, hX'‚ü© := ((cor1 hm ht hŒµ hn hS hU).2 ((range t).bUnion Ws)).resolve_left
      (by simpa using h') Ws _ _ hS',
    { refine ‚ü®X, _‚ü©,
      simp only [shadow, mem_filter, hX, hX', and_self] },
    sorry },
  sorry
end

theorem Lem2 (S : finset (finset Œ±)) (W : finset(finset Œ±) ) (t m: ‚Ñï )
(hel : ‚àÄT ‚àà S, (finset.card T:‚Ñù ) ‚â§ (2^t:‚Ñù ) ) (h_sp : spread (m*64‚Åª¬π / (fintype.card Œ± )‚Åª¬π) S):
  (finset.card ((univ.powerset_len (m * t)).filter (Œª w, ‚àÄT ‚àà S, ¬¨ (T ‚äÜ w) )) : ‚Ñù) ‚â§
    (nat.choose (fintype.card Œ±) (m*t)) / 8 :=
begin
  sorry
end

theorem Cor2_easyver (S : finset (finset Œ±) )(n k w m:‚Ñï )(hSk : ‚àÄT‚ààS, finset.card T = k) (hk : 2 ‚â§ k)
(hn : n = 2*w*m*t) ( Œµ:‚Ñù ) (he : 0 ‚â§ Œµ ) (hspr : spread Œµ S) :
 ‚àÉ(T : finset (finset Œ± ) ),  (T ‚äÜ S) ‚àß  (‚àÄ B‚ÇÅ  B‚ÇÇ ‚àà T, B‚ÇÅ ‚â† B‚ÇÇ ‚Üí  disjoint B‚ÇÅ B‚ÇÇ )
 ‚àß (2^(-9 : ‚Ñù )*Œµ‚Åª¬π/(real.logb  2 k) ‚â§ T.card ) :=
begin
  set t:= nat.ceil (real.logb 2 k) with ht,
  have h_t_le : real.logb 2 k ‚â§ t,
  {
    rw ht, exact nat.le_ceil (real.logb 2 ‚Üëk),
  },


  sorry

end


theorem Cor2 (S : finset (finset Œ±) )( k:‚Ñï )(hSk : ‚àÄT‚ààS, finset.card T = k)
( Œµ:‚Ñù ) (he : 0 ‚â§ Œµ ) (hspr : spread Œµ S) : 2 ‚â§ k ‚Üí  ‚àÉ(T : finset (finset Œ± ) ),
 (T ‚äÜ S) ‚àß  (‚àÄ B‚ÇÅ  B‚ÇÇ ‚àà T, B‚ÇÅ ‚â† B‚ÇÇ ‚Üí  disjoint B‚ÇÅ B‚ÇÇ ) ‚àß  (2^(-9 : ‚Ñù )*Œµ‚Åª¬π/(real.logb  2 k) ‚â§ T.card ) :=
begin
  set t:= nat.ceil (real.logb 2 k) with ht,
  have h_t_le : real.logb 2 k ‚â§ t := nat.le_ceil (real.logb 2 ‚Üëk),


--Choose random partiiton of [n]

--Lemma2 is applicable

--Apply Lemma 2

--Expectation > w implies actual such case

--use the right T

--split,

sorry
end

--Using different index. We use w+1 , k+1 for w, k in the paper. Then we can have induction from k=1,
--and we don't need the prooves that 1 ‚â§ w,k.

def sunflower {Œ± : Type*}[decidable_eq Œ± ] (S : finset (finset Œ± )) (num_petal: ‚Ñï ) : Prop :=
  (finset.card S = num_petal) ‚àß (‚àÉ(C : finset Œ±), ‚àÄ P‚ÇÅ P‚ÇÇ ‚àà S, P‚ÇÅ ‚â† P‚ÇÇ ‚Üí  P‚ÇÅ ‚à© P‚ÇÇ = C)

def Thm3 (w : ‚Ñï)(k: ‚Ñï ){S: finset (finset Œ± )} (hT : ‚àÄ T ‚àà S, finset.card T = k+1)
: Prop :=  ‚àÉr : ‚Ñù , r ‚â§  (2:‚Ñù)^(10:‚Ñù)*(w+1 : ‚Ñù )*(real.logb 2 (k+1)) ‚àß (r^(k+1) ‚â§ S.card ‚Üí ‚àÉF‚äÜS, ( sunflower F (w+1)))


def smaller_sunflower {Œ± : Type*}[decidable_eq Œ± ] (S : finset (finset Œ± )) (Z : finset Œ±) : finset (finset Œ± ) :=
S.image (Œª s, s \ Z)

lemma sunflower_iff_smaller {S : finset (finset Œ±)} {Z : finset Œ±} (n: ‚Ñï) (h : ‚àÄ s ‚àà S, Z ‚äÜ s) :
  sunflower S n ‚Üî sunflower (smaller_sunflower S Z) n :=
begin
  have injective : set.inj_on (Œª s, s \ Z) S,
  { intros a ha b hb hab,
    dsimp at hab,
    have hZa : Z ‚äÜ a := h a ha,
    have hZb : Z ‚äÜ b := h b hb,
    suffices : (a \ Z) ‚à™ Z = (b \ Z) ‚à™ Z,
    { 
      sorry,
    },
    { rw hab, }
  },
  split,
  { intro hS,
    cases hS with hS1 hS2,
    refine ‚ü®_, _‚ü©,
    { 
      sorry
    },
    {
      sorry
    },
  },
  {
  sorry
  },
end


theorem Thm3' {w : ‚Ñï}(k : ‚Ñï ){r: ‚Ñù}{S: finset (finset Œ± )}  (hT : ‚àÄ T ‚àà S, finset.card T = k+1) 
: (w+1 : ‚Ñù) = r ‚Üí (real.logb 2 (k+1) = r * (2^9)‚Åª¬π * (w+1)‚Åª¬π ) ‚Üí  (r^(k+1) ‚â§ finset.card S) ‚Üí ‚àÉF‚äÜS, ( sunflower F (w+1)) :=
-- I think r can be equal to 2^9 * w * log(k+1) and w+1 = r
begin
  induction k using nat.case_strong_induction_on with k ih generalizing S,
  {
    simp at *,
    intros hwr h_log hrkS, --- I dont understand k=0 case.
    have hU : ‚àÉU ‚äÜ S, (finset.card U  = w+1) ‚àß (‚àÄ P‚ÇÅ P‚ÇÇ ‚àà U, P‚ÇÅ ‚â† P‚ÇÇ ‚Üí  disjoint P‚ÇÅ P‚ÇÇ),
    {
      rw ‚Üê hwr at hrkS, norm_cast at hrkS, --push_cast
      have tmp := exists_smaller_set S (w+1) hrkS,
      cases tmp, use tmp_w,
      split,
      { exact tmp_h.1 },
      {split, exact tmp_h.2,
        intros P1 hP1 P2 hP2 h12,
        have h_sing : ‚àÄP ‚àà tmp_w, finset.card P = 1 :=
        begin
          rw subset_iff at tmp_h, intros P hPP,
          have hSS := tmp_h.1 hPP, exact hT P hSS,
        end,
        obtain ‚ü®p1, rfl ‚ü© := finset.card_eq_one.1 (h_sing P1 hP1),
        obtain ‚ü®p2, rfl ‚ü©:= finset.card_eq_one.1 (h_sing P2 hP2),
        simp,
        intro P12,
        exact h12 (finset.singleton_inj.2 P12),
      },
    },

    rcases hU with ‚ü®U,hU1,hU2,hU3‚ü©,
    use U, split, exact hU1,
    split, exact hU2,
    use ‚àÖ,
    simp only [ finset.disjoint_iff_inter_eq_empty] at hU3,
    exact hU3,
  },

  {
    intros hwr hn hrkS,
    by_contra, simp at h,

    -- S is not (r‚Åª¬π)-spread
    have h_S_nspread : ¬¨(spread r‚Åª¬π S ),
    {
      by_contra htmp,
      have k2tmp : 2 ‚â§ k + 2 := by linarith,
      have rinv_pos : 0 ‚â§ r‚Åª¬π := begin rw ‚Üê hwr, apply le_of_lt, rw inv_pos, exact w.cast_add_one_pos,  end,
      have COR2:= Cor2 S (k+2) hT r‚Åª¬π rinv_pos htmp k2tmp,
      rcases COR2 with ‚ü®Ttmp,hTT1, hTT2, hTT3‚ü©,
      have hTtmpcard : (w+1) ‚â§ finset.card Ttmp,
      {
        simp at hn, simp at hTT3,
        sorry,
      },
      have Ttmptmp := exists_smaller_set Ttmp (w+1) hTtmpcard,
      rcases Ttmptmp with ‚ü®C, hC1, hC2 ‚ü©,
      specialize h C (subset_trans hC1 hTT1),
      apply h,
      split, exact hC2,
      use ‚àÖ,
      intros P1 hP1 P2 hP2 h12, 
      simp only [ finset.disjoint_iff_inter_eq_empty] at hTT2,
      apply hTT2 P1 (subset_iff.1 hC1 hP1) P2 ( subset_iff.1 hC1 hP2) h12,
    },

    -- Construction of Z and S'
    have hZ : ‚àÉ(Z:finset Œ±), (finset.card (S.filter (Œª s, Z ‚äÜ s)) : ‚Ñù) > r^(k- finset.card Z),
    {
      by_contra h_con, simp at h_con,
      apply h_S_nspread, 
      unfold spread,
      intros Z, 
      specialize h_con Z, 
      have temp : r ^ (k - Z.card) ‚â§ r‚Åª¬π ^ Z.card * ‚Üë(S.card),
      {
        --use hrKS and hwr
        sorry
      },
      convert (le_trans h_con temp),
    },
    rcases hZ with ‚ü®Z,hZ‚ü©,
    --define S'
    let S' := S.filter (Œª s, Z ‚äÜ s), 

    -- S'' is the sunflower
    have hSmall :  sunflower (smaller_sunflower S' Z) (w+1), --change that some subset of S' is a sunflower
    {
      sorry --nontrivial sorry but not hard
    },
    --S is the sunflower
    have h_contains_Z :  ‚àÄ s ‚àà S', Z ‚äÜ s,
    {
      intros s, rw finset.mem_filter, intros hs, exact hs.2,
    },
    have hSprime : sunflower S' (w+1) := (sunflower_iff_smaller (w+1) h_contains_Z).2 hSmall,
    apply h S' (finset.filter_subset (Œª s, Z ‚äÜ s) S) hSprime,
  }
end





/-theorem Thm3 {w k : ‚Ñï}{S: finset (finset Œ± )} (hw : 1 ‚â§ w) ( hk : 1 ‚â§ k) (hT : ‚àÄ T ‚àà S, finset.card T = k)
: ‚àÉr : ‚Ñù , r ‚â§  (2:‚Ñù)^(10:‚Ñù)*(w : ‚Ñù )*(real.logb 2 k) ‚àß
(r^k ‚â§ S.card ‚Üí ‚àÉF‚äÜS, ( sunflower F w)) :=
begin

sorry

end -/
